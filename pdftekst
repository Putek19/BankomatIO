
1

Automatic Zoom
Cel zajęć: Weryfikacja poprawności działania tworzonego oprogramowania przy pomocy testów jednostkowych.
Źródła wiedzy: Wykład IO: Testowanie oprogramowania (dostępny też w ePortalu Pwr).
Przykład: Miniprojekt Biblioteka (dostępny też w ePortalu PWr).
Tutorial do JUnit6: JUnit User Guide.
Tutorial do Mockito: Class Mockito.
Zawartość instrukcji: 3 zadania – ich wykonanie jest oceniane.
Spis rzeczy, które należy umieścić w sprawozdaniu z wykonania zadań.
Spis błędów i braków mogących obniżyć ocenę.
Zadania
Zadanie 1
Weryfikacja poprawności działania tworzonego oprogramowania przy pomocy testów jednostkowych
– testy operacji niezależnych lub zależnych tylko od operacji przetestowanych
Należy sprawdzić poprawność działania wykonanego oprogramowania, wykonując jednostkowe testy działania opera-
cji realizujących bardziej skomplikowane zadania biznesowe bez użycia symulacji („mockowania”). Testy należy wykonać
w odpowiedniej kolejności, zaconując testy operacji od nich zależ-
nych itd. Kolejność testowania operacji można wywnioskować z diagramów klas i sekwencji, wykonanych na wcześniej-
szych etapach laboratoriów, ponieważ pokazują zależności między klasami i między operacjami.
Testy należy wykonać w wybranym środowisku IDE przy pomoblioteki (dla języka Java zaleca się
użycie JUnit6).
Każda klasa testów (np. TestKsiążka.java) powinna:
– testować operacje klasy, której nazwa jest częścią jej nazwy (np. Książka.java);
– określać nazwę klasy testów i nazwę testu (adnotacja @DisplayName w JUnit6);
– określać kolejność wykonania testów operacji (adnotacje @Order, @TestMethodOrder w JUnit6);
– opisywśli, gdy, wtedy).
Nie ma minimalnej liczby operacji do przetestowania, ale w sumie klasy testów powinny:
– przygotować dane do testu (operacje setUp() i setUpBeforeClass() i adnotacje @BeforeEach, @BeforeAll w JUnit6);
– posprzątać dane po teście (operacje tearDown() i tearDownAfterClass() i adnotacje @AfterEach, @AfterAll w JUnit6);
– wykorzystać przynajmniej 3 różne asercje (assertEquals(), assertNotEquals(), assertIterableEquals(), assertSame(), as-
sertNull(), assertNotNull(), ssertFalse(), assertThrows() i inne w JUnit6);
– wykorzystać przynajmniej 2 różne sposoby parametryzowania testu, aby wykonać go dla różnych wartości parametrów
wejściowych (przy pomocy adnotacji @ParameterizedTest, @Parameter, @ValueSource, @CsvSource, @MethodSource,
@FieldSource w JUnit6).
Powyższe przykłady operacji i adnotacji nie wyczerpują możliwości JUnit6.
Jednostkowy test operacji:
Sprawdza, czy pojedyncza operacja działa zgodnie z oczekiwaniem. Poprawność działania operacji i poprawność jej
wyniku sprawdzana jest w izolacji od innych, zwłaszcza nieprzetestowanych części kodu (obiektów, klas, lub operacja zwykle na utworzeniu obiektu testowanej klasy i wywołniu jego testowanej operacji z okre-
ślonymi parametrami operacji (jeśli je posiada).
Rzeczywisty wynik testu porównuje się z oczekiwanym wynikiem (przy pomocy asercji) w celu wykrycia błędów kodu
w wyniku lub efektach ubocznych (np. w zmianie stanu testowanego lub innego obiektu) działania testowanej operacji.
dr inż. Paweł Głuchowski Inżynieria Oprogramowania zapisano 12 I 2026
Wydział Informatyki i Telekomunikacji laboratoria 11
Politechnika Wrocławska Testowanie jednostkowe operacji ria 12—13
Testowanie jednostkowe operacji klas
Inżynieria Oprogramowania
Etapy testu:
1) Jeśli (ang. given): utworzenie obiektów będących parametrami wejściowymi testowanej operacji i obiektów będących
spodziewanym wynikiem tej operacji (do porównania z jej rzeczywistym wynikiem).
2) Gdy (ang. when): wykonanie testowanej operacji.
3) Wtedy (ang. then): porównanie rzeczywistego wyniku operacji ze spodziewanymsercje.
Kolejność wykonania jednostkowych testów:
Najpierw testuje się operacje niezależne, następnie operacje zależne od tych już przetestowanych itd. Zależna opera-
cja to taka, która w parametrze lub w ciele zawiera wykonanie innej operacji z tej samej lub innej klasy, albo wykorzysta-
nie atrybutu z tej samej lub innej klasy.
W architekturze n-warstwowej zaczyna się od testowania klas warstwy niezależnej (zwykle jest to warstwa encji), na-
stępnie testuje się klasy warstw bezpośrednio od niej zależnych (np. warstwy kontroli), następnie klasy warstw bezpo -
srednio od nich zależnych itd.
Przykładowa kolejność testów jednostkowych dla warstw encji (model w MVC) i kontroli (kontroler w MVC):
1) Testy klas modelujących encje danych w warstwie encji.
2) Testy klas modelujących zadania biznesowe encji (np. tencji danych) w warstwie encji.
3) Testy klas modelujących elementarne usługi biznesowe (np. krok realizacji przypadku użycia) w warstwie kontroli.
4) Testy klas modelujących złożone usługi biznesowe (np. realizację całego przypadku użycia) w warstwie kontroli.
Zadanie 2
Weryfikacja poprawności działania tworzonego oprogramowania przy pomocy testów jednostkowych
– symulacja obiektów i operacji, od których zależy testowana operacja
Należy sprawdzić poprawność działania wykonanego oprogramowania, wykonując jednostkowe testy działania opera-
cji realizujących bardziej skomplikowane zadania biznesowe z użyciem symulacji („mockowania”). Symulować należy te
fragmenty kondu (obiekty, operacje), od których zależy testowana operacja. Te zależności można wywnioskować z diagra-
mów klas i sekwencji, wykonanych na wczeeży wykonać zgodnie z wymaganiami zadania 1, w wybranym środowisku IDE przy pomocy odpowiednich bi-
bliotek (dla języka Java zaleca się użycie JUnit6 i Mockito).
Nie ma minimalnej liczby operacji do przetestowania, ale w sumie klasy testów powinny:
– tworzyć symulacje obiektu lub klasy (operacja mock() lub adnotacja @Mock oraz operacja initMocks() w Mockito);
– wstrzykiwać do symulacji inne symulacje, od których jest zależna (adnotacja @InjectMocks w Mockito);
– określać zachowanie symulacji operacji coś zwracających: co zwraca (operacja when().thenReturn() w Mockito) lub jaki
wyjątek wyrzuca (operacja when().thenThrow() w Mockito);
– określać zachowanie symulacji operacji niczego niezwracających (void): co zwraca (operacja doReturn().when() w Moc-
kito) lub jaki wyjątek wyrzuca (operacja doThrow().when() w Mockito) i innne (operacje doNothing().when() i doCallReal-
Method().when() w Mockito).
Ponaeślać kolejność użycia symulacji (klasa inOrder w Mockito);
– sprawdzać, czy, ile razy i z jakimi parametrami symulację użyto w teście (operacje verify(), times(), never(), atLeast(),
atLeastOnce(), atMost(), atMostOnce() w Mockito).
Powyższe przykłady operacji i adnotacji nie wyczerpują możliwości Mockito.
Symulacja / atrapa / imitacja zależności testowanej operacji:
Jeśli izolacja testowanej operacji nie jest możliwa, a testowana operacja korzysta z działania lub wyniku innej, nie -
przetestowanej, niedostępnej lub nieprzewidywalnie zachowującej się części kodu (obiektu, klasy, operacji lub jej wyniku),
to tę inną część kodu lub jego zachowanie się symuluje, czyli imituje („mockuje”).
Test wykorzystujący symulację nie gwarantuje poprawności działania testowanej operacji w przypadku zastosowania
rzeczywistej zależnej części kodu.
Symulacja w etapach testu:
1) Jeśli (ang. given): utworzenie i określenie użycia i zachowania symulacji (atrap).
2) Gdy (ang. wsymulacji (atrapy).
3) Wtedy (ang. then): sprawdzenie użycia symulacji (atrapy) przed użyciem asercji.
dr inż. Paweł Głuchowski Inżynieria Oprogramowania zapisano 12 I 2026
Wydział Informatyki i Telekomunikacji laboratoria 11
Politechnika Wrocławska Testowanie jednostkowe operacji klas 2

